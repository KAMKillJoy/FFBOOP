![notlogo](.github_assets/some_screen.png)

# FF8MBOOP

Обёртка FFmpeg с установкой параметров через консольное меню.

## История проекта и что это вообще такое

Я играю в игры и часто сохраняю забавные моменты, чтобы показать друзьям в дискорде. Ограничение дискорда в 8MB на файл
привело к тому, что родился скрипт FF8MB.py. То есть скрипт, который с помощью FFmpeg конвертирует файл в 8MB.
Скрипт этот представлял собой процедурную "спагетину", которую надо было редактировать под каждый файл, рассчитывая
нужный битрейт руками.

Со временем мои знания Python и FFmpeg улучшались и новая итерация FF8MB уже использовала не постоянный битрейт (CBR), а
Constant Rate Factor. Ограничение в 8MB перестало быть актуальным. Та версия всё ещё была монолитной "спагетиной" почти
без определения своих функций.

Оно отлично работало, но мне не было покоя. Поддерживать и расширять такое очень трудно. Под новый кодек нужно было
копировать скрипт и переписывать специфичные для кодека места. Мне хотелось реализовать что-то более универсальное и
расширяемое.

Архитектуру OOP-реализации я периодически обдумывал в течение многих лет. Опыта OOP почти не было, так что было
непросто. Так я начинал и забивал раз 5, пока не обсудил оптимальную архитектуру с нейронкой.
После перебора весьма непродуктивных предложений, удалось таки понять какой вариант реализации был бы наиболее логичным
и удобным для меня. Его вы видите тут.

## Суть реализации

Сердцем данной реализации является **my_codecs.py**. Здесь реализован базовый класс Codec и его экземпляры. Каждый
экземпляр это "модель" кодека, которая описывает какие параметры можно настраивать и какие значения параметры принимают.
Таким образом, можно легко добавить новый кодек, просто скопировав и отредактировав экземпляр другого кодека.

**menu.py** Составляет меню на базе списка (вообще-то словаря) параметров кодека, так что, фактически, меню
актуализируется самостоятельно под новый кодек.
Есть три типа параметров и соответствующие им реализации подменю:

- со свободным вводом:
  В экземпляре кодека данному параметру не задаются никакие варианты и ограничения. Вместо этого задаётся None. В таком
  случае, меню просто принимает любой ввод.
- с выбором из вариантов:
  В экземпляре кодека данному параметру задаются варианты значения в виде списка. Тогда меню предлагает вам выбрать из
  возможных вариантов.
- **уникальный параметр** или **параметр с собственной обработкой**:
  Что там указано в экземпляре кодека не играет роли. Мы реализуем уникальную логику для данного параметра
  самостоятельно, "перехватывая" универсальный метод handle_param(). Пример такого параметра является scale и его
  реализация через handle_scale(). Обратите внимание на механизм перехвата:

    ```
    if param == "scale":
        self.handle_scale() 
    ```

  Так можно реализовать индивидуальную обработку любого параметра.

  **ВАЖНО**: Эти параметры в экземпляре Codec могут выглядеть как первые два. Их "уникальность" задаётся внутри класса
  menu.py -> Menu

**commander.py** Данный модуль принимает настройки, заданные через меню и составляет итоговую команду FFmpeg согласно
этим настройкам. При добавлении новых параметров в Codec, нужно также расширить генерацию команды в commander.py — это
точка, где логика связывается с FFmpeg.

**converter.py** Универсальный лаунчер, который спрашивает какой из поддерживаемых кодеков вы хотите использовать,
выводит
соответсвующее меню, генерирует команду FFmpeg и прогоняет её для всех файлов.

**converter_%some_name%** Лаунчер, который запускает converter.py с двумя возможными аргументами функции main():

- preselected_codec - имя поддерживаемого кодека из my_codecs.py. Позволяет пропустить меню выбора кодека.
- skip_menu - значение True/False, которое позволяет пропустить меню и приступить к рендеру с настройками из
  options.json

**options.json** Стандартные настройки параметров кодека, которые подгружаются при запуске лаунчера. Можно
отредактировать под свой сценарий.

## Зависимости

- Python. Достаточно новый, чтобы поддерживать f-строки.
- FFmpeg добавленный в path

## Как использовать?

### Drag and Drop

Перетащите видеофайлы на converter по вкусу, установите настройки (если надо), нажмите enter и ждите пока FFmpeg сделает
своё дело. Готовые файлы будут лежать в папке Output в папке проекта.
Вероятно, ваша ОС не разрешает Drag & Drop файлов на файлы Python. Что ж, вот что с этим делать:

- ничего, потому что это просто тренировочный проект, реализующий не самый широкий сценарий взаимодействия с FFmpeg и
  никто не будет пользоваться им, когда есть куча GUI.
- погуглить как включить Drag & Drop файлов на файлы Python.
- добавить скрипт в виде кнопки в вашем файловом менеджере а-ля Total Commander.

### Аргументы запуска

Все converter'ы поддерживают аргументы запуска:

```
positional arguments:
files                     Input video files, separated by space

options:
-h, --help                show this help message and exit
--codec CODEC             Codec to use (e.g., h264, hevc, vp9)
--skip-menu               Skip interactive menu
--output-dir OUTPUT_DIR   Override output directory
```

### Гибридный вариант

Энтузиасты могут реализовать гибридный вариант, который принимает файлы через drag and drop, но также принимает
аргументы запуска, включая позиционный аргумент files. Реализуется это через файловые менеджеры (Total Commander, Double
Commander, etc) или батники, ярлыки windows.

## Как добавить поддержку кодека?

В модуле my_codecs.py добавить новый экземпляр Codec, по аналогии с теми кодеками что уже там есть. Просто посмотрите
как оно выглядит и всё поймёте.
При желании можно сделать converter для вашего кодека по аналогии с уже существующими.

## TO DO or not TO DO

Что я хотел бы сделать лучше или иначе, но скорее всего не буду:

- Добавить возможность задать альтернативный текст подсказки для подменю без переопределения всего метода.
- Может вместо стандартных значений сохранять и использовать настройки предыдущего прогона? (сомнительно)
- Добавить красивый прогресс бар
- Сделать автоматическую сборку в exe через GithubActions?
- ~~Лаунчер, который пропускает меню и сразу рендерит со стандартными параметрами.~~ (реализовано)

